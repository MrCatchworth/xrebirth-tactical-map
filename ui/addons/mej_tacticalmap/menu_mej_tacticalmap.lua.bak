local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef uint64_t UniverseID;
	typedef struct {
		const char* factionName;
		const char* factionIcon;
	} FactionDetails;
	typedef struct {
		UniverseID softtargetID;
		const char* softtargetName;
		const char* softtargetConnectionName;
	} SofttargetDetails;
	typedef struct {
		float x;
		float y;
		float z;
		float yaw;
		float pitch;
		float roll;
	} UIPosRot;
	void AbortPlayerPrimaryShipJump(void);
	UniverseID AddHoloMap(const char* texturename, float x0, float x1, float y0, float y1);
	void ClearHighlightMapComponent(UniverseID holomapid);
	const char* GetBuildSourceSequence(UniverseID componentid);
	const char* GetComponentClass(UniverseID componentid);
	const char* GetComponentName(UniverseID componentid);
	UniverseID GetContextByClass(UniverseID componentid, const char* classname, bool includeself);
	FactionDetails GetFactionDetails(const char* factionid);
	UniverseID GetMapComponentBelowCamera(UniverseID holomapid);
	bool GetMapPositionOnEcliptic(UniverseID holomapid, UIPosRot* position, bool showposition);
	const char* GetMapShortName(UniverseID componentid);
	FactionDetails GetOwnerDetails(UniverseID componentid);
	UniverseID GetParentComponent(UniverseID componentid);
	UniverseID GetPickedMapComponent(UniverseID holomapid);
	SofttargetDetails GetSofttarget(void);
	UniverseID GetZoneAt(UniverseID sectorid, UIPosRot* uioffset);
	bool HasPlayerJumpKickstarter(void);
	bool InitPlayerPrimaryShipJump(UniverseID objectid);
	bool IsComponentOperational(UniverseID componentid);
	bool IsInfoUnlockedForPlayer(UniverseID componentid, const char* infostring);
	bool IsSellOffer(UniverseID tradeofferdockid);
	void RemoveHoloMap2(void);
	void SetHighlightMapComponent(UniverseID holomapid, UniverseID componentid, bool resetplayerpan);
	bool SetSofttarget(UniverseID componentid);
	void ShowUniverseMap(UniverseID holomapid, UniverseID componentid, bool resetplayerzoom, int overridezoom);
	void StartPanMap(UniverseID holomapid);
	void StartRotateMap(UniverseID holomapid);
	void StopPanMap(UniverseID holomapid);
	void StopRotateMap(UniverseID holomapid);
	void ZoomMap(UniverseID holomapid, float zoomstep);
    bool IsShip(const UniverseID componentid);
]]

local menu = {
    name = "MeJ_TacticalMapMenu",
    white = { r = 255, g = 255, b = 255, a = 100 },
    red = { r = 255, g = 0, b = 0, a = 100 },
    transparent = { r = 0, g = 0, b = 0, a = 0 },
    grey = { r = 128, g = 128, b = 128, a = 100 },
    
    issuableOrders = {},
    gridOrders = {},
    commandAcceptSound = "ui_speedbar_fullforward",
    commandRejectSound = "ui_interaction_not_possible",
    
    text = {
        zoomOut = ReadText(1005, 77),
        zoomIn = ReadText(1005, 76),
        details = ReadText(1001, 2961),
        comm = ReadText(1001, 3216),
        back = ReadText(1001, 2669),
        selectionNone = "-- " .. ReadText(1001, 34) .. " --",
        commandAccepted = ReadText(10002, 132),
        commandRejected = ReadText(10002, 133),
        unknown = ReadText(20214, 100),
        show = ReadText(1001, 1133),
        unknownSystem = ReadText(20006, 101),
        plotCourse = ReadText(1001, 1109),
        abortCourse = ReadText(1001, 1110)
    }
}



local colorChar = string.char(27)
local function textColor(suffix)
    return colorChar..suffix
end

local function loadOrdersFromExtensions()
    DebugError("TACTICAL MAP: LOADING ORDERS DEFINED IN EXTENSIONS")
    local extensions = GetExtensionList()
    
    for k, extension in ipairs(extensions) do
        local path = "extensions/" .. string.gsub(extension.location, "\\", "/") .. "mej_tacmap_orders.txt"
        local loadedChunk = loadfile(path)
        
        local retVal
        if loadedChunk then
            retVal = loadedChunk()
        end
        
        if retVal then
            DebugError("Tactical map order definitions found in " .. extension.name)
            if retVal.issuableOrders then
                for k, rightClickOrder in ipairs(retVal.issuableOrders) do
                    table.insert(menu.issuableOrders, rightClickOrder)
                end
            end
            if retVal.gridOrders then
                for k, gridOrder in ipairs(retVal.gridOrders) do
                    table.insert(menu.gridOrders, gridOrder)
                end
            end
        end
    end
    
    DebugError("Tactical map: finished loading from extensions. "..#menu.issuableOrders.." right-click orders and "..#menu.gridOrders.." grid orders")
end

local function init()
    Menus = Menus or { }
    table.insert(Menus, menu)
    if Helper then
        Helper.registerMenu(menu)
    end
    menu.holomap = 0
    
    loadOrdersFromExtensions()
    
    --fill gridOrders a bit
    while #menu.gridOrders < 12 do
        local num = #menu.gridOrders
        table.insert(menu.gridOrders,
            {
                buttonText = "--",
                
                requiresTarget = false,
                
                buttonFilter = function(order) return false end,
                
                issue = function(order) end
            }
        )
    end
end

function menu.onShowMenu()
    Helper.standardFontSize = 9
    Helper.standardTextHeight = 14

    menu.renderTargetWidth = Helper.standardSizeY - 30
    menu.renderTargetHeight = Helper.standardSizeY
    menu.selectTableOffsetX = menu.renderTargetWidth
    menu.selectTableHeight = Helper.standardSizeY - 20 - 100
    menu.commandTableOffsetY = menu.selectTableHeight + 5
    menu.statusBarWidth = 25
    menu.extendButtonWidth = 30
    
    --calculate row widths:
    --there are 9 elements: 4 buttons and 5 spaces
    --a button is about 3 times the width of a space
    --total 'weight' is 12 for buttons and 5 for spaces
    local buttonTableButtonShare = 14
    local buttonTableSpacerShare = 4
    local buttonTableTotalShare = buttonTableButtonShare + buttonTableSpacerShare
    menu.buttonTableButtonWidth = (buttonTableButtonShare/buttonTableTotalShare) * (menu.renderTargetWidth-25) / 4
    menu.buttonTableSpacerWidth = (buttonTableSpacerShare/buttonTableTotalShare) * (menu.renderTargetWidth-25) / 5
    
    local productionColor, buildColor, storageColor, radarColor, dronedockColor, efficiencyColor, defenceColor, playerColor, friendColor, enemyColor, missionColor = GetHoloMapColors()
    menu.holomapColor = { productionColor = productionColor, buildColor = buildColor, storageColor = storageColor, radarColor = radarColor, dronedockColor = dronedockColor, efficiencyColor = efficiencyColor, defenceColor = defenceColor, playerColor = playerColor, friendColor = friendColor, enemyColor = enemyColor, missionColor = missionColor }
    
    --used to detect whether a select was made with left or right click
    menu.timeLastMouseDown = 0
    menu.timeLastRightMouseDown = 0
    
    --selected component (ship, space, whatever)
    menu.currentSelection = 0
    
    --player ship to perform a command, and the target
    menu.commandSelection = 0
    menu.commandTarget = 0
    menu.commandTargetType = "none"
    --commandTargetType is one of "none", "object", "point"
    menu.commandSelectionRow = 0
    menu.commandRowDirty = false
    
    --used to control holomap updates
    menu.lastHolomapUpdate = GetCurRealTime() + menu.holomapUpdateInterval
    
    --mapClicked uses this to tell displayMenu what should be selected in the menu
    menu.nextSelection = 0
    
    --displayMenu was triggered by selecting on the holomap, don't ignore the row change
    menu.displayDueToTarget = false
    --the next n row changes on selectTable will have no effect
    menu.ignoreSelectRowChange = 0
    
    menu.nextSelectedRow = 0
    
    menu.extendedObjects = {}
    menu.extend(GetPlayerPrimaryShipID())
    
    --when you don't want to wait for updateHolomap to be called naturally
    --eg an order was issued and you want to update quickly, but not so quickly the command doesn't update on the UI
    menu.nextUpdateQuickly = false
    
    --if a component has its tostring as a key, it's checked, the value doesn't matter
    menu.checkedComponents = {}
    menu.numChecked = 0
    menu.multiSelectMode = false
    
    --a text message you can put above the 4 buttons if you like
    menu.statusMessage = "Ready"
    
    --some grid orders can be specify that they still need a target. if you click on one, its table goes here and will intercept the next right click
    menu.activeGridOrder = nil
    
    menu.displayMenuRunning = false
    
    --set some button scripts we don't have to mess with
    for k, order in ipairs(menu.gridOrders) do
        order.buttonScript = function()
            if menu.activeGridOrder == order then
                menu.setActiveGridOrder(nil)
                return
            end
            if order.requiresTarget then
                menu.setActiveGridOrder(order)
                return
            end
            local orderObj = menu.getOrderObject(true)
            if orderObj.subject ~= 0 and order.buttonFilter(orderObj) then
                PlaySound(menu.commandAcceptSound)
                order.issue(orderObj)
            end
        end
    end
    
    --parse params
    if menu.param then
        local paramSource = menu.param
        if menu.param2 and not menu.param2[1] then
            paramSource = menu.param2
        end
        
        menu.currentSpace = ConvertIDTo64Bit(paramSource[4])
        menu.currentSpaceType = paramSource[3]
        menu.nextSelection = paramSource[6] or 0
        menu.mode = paramSource[7]
        menu.modeParams = paramSource[8] or {}
        
        if paramSource == menu.param and menu.param2 and menu.nextSelection == 0 then
			menu.lastchild = ConvertIDTo64Bit(menu.param2[2]) or 0
		end
    else
        menu.currentSpace = C.GetContextByClass(ConvertIDTo64Bit(GetPlayerPrimaryShipID()), "zone", false)
        menu.currentSpaceType = "zone"
    end
    
    --create child list (this actually sets up the menu)
    menu.displayMenuReason = "open menu"
    menu.displayMenu(true)
    
    --set the activatemap flag
    menu.activateMap = true
    
    RegisterEvent("updateHolomap", menu.updateHolomap)
    
    menu.shouldBeClosed = false
    
    menu.rowChangeCount = 0
    menu.rowChangeMessage = ""
    
    RegisterAddonBindings("ego_detailmonitor")
end

--applies stuff like soft target and autopilot arrows
local function applyTargetArrows(setup, component, name)
    --softtarget arrows
    if IsSameComponent(component, GetPlayerTarget()) then
        name = "> "..name.." <"
    end
    
    --autopilot arrows
    if IsSameComponent(component, GetAutoPilotTarget()) then
        name = ">> "..name
    end
    
    return name
end

local function getCommandString(pilot, includeAction)
    if not pilot then
        return "--"
    end
    
    local commandString = "--"
    local commandActionString = "--"
    local commandParamString = "--"
    local commandActionParamString = "--"
    
    local commandStack, command, commandParam, commandAction, commandActionParam = GetComponentData(pilot, "aicommandstack", "aicommand", "aicommandparam", "aicommandaction", "aicommandactionparam")
    
    local numCommands = #commandStack
    if numCommands > 0 then
        command = commandStack[1].command
        commandParam = commandStack[1].param
    end
    if numCommands > 1 then
        commandAction = commandStack[numCommands].command
        commandActionParam = commandStack[numCommands].param
    end
    commandParamString = IsComponentClass(commandParam, "component") and GetComponentData(commandParam, "name") or ""
    commandActionParamString = IsComponentClass(commandActionParam, "component") and GetComponentData(commandActionParam, "name") or ""
    
    commandString = string.format(command, commandParamString)
    commandActionString = string.format(commandAction, commandActionParamString)
    if includeAction then
        return commandString, commandActionString
    else
        return commandString
    end
end

--for display on the top-right of buttonTable
local function getComponentInfo(component)
    if component == 0 or not IsComponentOperational(component) then
        return ""
    elseif IsComponentClass(component, "space") then
        local ownerName = GetComponentData(component, "ownername")
        if ownerName then
            return "Policed by " .. ownerName
        else
            return ""
        end
    elseif not menu.canViewDetails(component) then
        return ""
    else
        local infoItems = {}
        local separator = colorChar .. "Z" .. " - " .. colorChar .. "X"
        
        if IsComponentClass(component, "container") then
            if IsComponentClass(component, "ship") and IsInfoUnlockedForPlayer(component, "operator_commands") then
                local command, action = getCommandString(GetComponentData(component, "pilot"), true)
                table.insert(infoItems, action)
            end
            
            local hullPct, shieldPct, shieldMax = GetComponentData(component, "hullpercent", "shieldpercent", "shieldmax")
            if shieldMax ~= 0 then
                table.insert(infoItems, colorChar .. "C" .. shieldPct)
            end
            table.insert(infoItems, hullPct)
            
            local storage = GetStorageData(component)
            if storage.capacity > 0 then
                local tildeMaybe = storage.estimated and "~ " or ""
                table.insert(infoItems, tildeMaybe .. ConvertIntegerString(storage.stored, true, 3, true) .. "/" .. ConvertIntegerString(storage.capacity, true, 3, true))
            end
        else
            return ""
        end
        
        return #infoItems > 0 and table.concat(infoItems, separator) or ""
    end
end

--return true iff the ship is suitable to display on the TOP LEVEL of the right-hand list
local function shouldDisplayShip(ship, sameSpaceType)
    if IsComponentClass(ship, "ship_xs") then return false end
    
    local commander = GetCommander(ship)
    if not commander or IsComponentClass(commander, "station") then
        return true
    else
        return not IsSameComponent(GetContextByClass(commander, sameSpaceType, false), GetContextByClass(ship, sameSpaceType, false))
    end
end

local function filterByDisplayable(shipList, sameSpaceType)
    for i = #shipList, 1, -1 do
        if not shouldDisplayShip(shipList[i], sameSpaceType) then
            table.remove(shipList, i)
        end
    end
    return shipList
end

function menu.refreshOrderButton(order, orderObj)
    Helper.removeButtonScripts(menu, menu.commandGridTable, order.row, order.col)
    SetCellContent(menu.commandGridTable, menu.getOrderButton(order, orderObj), order.row, order.col)
    Helper.setButtonScript(menu, nil, menu.commandGridTable, order.row, order.col, order.buttonScript)
end

function menu.setActiveGridOrder(newOrder)
    local orderObj = menu.getOrderObject(true)
    local oldOrder = menu.activeGridOrder
    menu.activeGridOrder = newOrder
    if oldOrder ~= nil then menu.refreshOrderButton(oldOrder, orderObj) end
    if newOrder ~= nil then menu.refreshOrderButton(newOrder, orderObj) end
end

local globalOrderObj = {}
function menu.getOrderObject(noTarget)
    menu.enforceSelections()
    globalOrderObj.subject = menu.commandSelection
    globalOrderObj.space = menu.currentSpace
    globalOrderObj.spaceType = menu.currentSpaceType
    globalOrderObj.menu = menu
    
    if noTarget then
        globalOrderObj.target = 0
        globalOrderObj.targetType = "none"
    else
        globalOrderObj.target = menu.commandTarget
        globalOrderObj.targetType = menu.commandTargetType
    end
    
    return globalOrderObj
end

function menu.setStatusMessage(msg, noset)
    menu.statusMessage = msg
    if not noset then Helper.updateCellText(menu.buttonTable, 1, 1, msg, menu.white) end
end

--helper function to get the highest commander in the chain that isn't the skunk
--(because orderable ships are either subordinate to the skunk or subordinate to nobody)
local function getHighestCommander(component)
    if IsSameComponent(component, GetPlayerPrimaryShipID()) then
        return nil
    end
    if not IsComponentClass(component, "ship") then
        return nil
    end
    if GetBuildAnchor(component) then
        return nil
    end
    if not GetCommander(component) then
        if GetComponentData(component, "pilot") then
            return component
        else
            return nil
        end
    end
    
    local commandChain = GetAllCommanders(component)
    local comm
    
    --find the top of the command chain - might still be not a valid command receiver!
    if #commandChain == 1 then
        if IsSameComponent(commandChain[1], GetPlayerPrimaryShipID()) then
            --direct subordinate to skunk, i can receive orders
            comm = component
        else
            --direct subordinate to someone who can receive orders
            comm = commandChain[1]
        end
    else
        if IsSameComponent(commandChain[#commandChain], GetPlayerPrimaryShipID()) then
            --skunk is at the top, next one down can receive orders
            comm = commandChain[#commandChain-1]
        else
            --someone who can receive orders is at the top
            comm = commandChain[#commandChain]
        end
    end
    if IsComponentClass(comm, "station") then
        --no way to give orders to a ship assigned to a station
        return nil
    end
    if not GetComponentData(comm, "pilot") then
        return nil
    end
    
    return comm
end

function menu.isExtended(ship)
    for k, v in ipairs(menu.extendedObjects) do
        if IsSameComponent(v, ship) then
            return true
        end
    end
    return false
end
function menu.extend(ship)
    --menu.extendedObjects[ship] = true
    if not menu.isExtended(ship) then
        table.insert(menu.extendedObjects, ship)
    end
end
function menu.collapse(ship)
    --menu.extendedObjects[ship] = nil
    for k, v in ipairs(menu.extendedObjects) do
        if IsSameComponent(v, ship) then
            table.remove(menu.extendedObjects, k)
        end
    end
end

local function getIconName(ship)
    local purpose = GetComponentData(ship, "primarypurpose")
    if IsComponentClass(ship, "ship_xs") then
        if purpose == "fight" then
            return "shipicon_drone_combat"
        else
            return "shipicon_drone_transport"
        end
        
    elseif IsComponentClass(ship, "ship_s") then
        return "shipicon_fighter_s"
        
    elseif IsComponentClass(ship, "ship_m") then
        if purpose == "fight" then
            return "shipicon_fighter_m"
        elseif purpose == "trade" then
            return "shipicon_freighter_m"
        elseif purpose == "mine" then
            return "shipicon_miner_ore_m"
            --return "mej_miner"
        end
        
    elseif IsComponentClass(ship, "ship_l") then
        if purpose == "fight" then
            return "shipicon_destroyer_l"
        elseif purpose == "build" then
            return "shipicon_builder_l"
        elseif purpose == "mine" then
            return "shipicon_miner_ore_l"
            --return "mej_miner"
        else
            return "shipicon_freighter_l"
        end
        
    elseif IsComponentClass(ship, "ship_xl") then
        if purpose == "fight" then
            return "shipicon_destroyer_xl"
        elseif purpose == "mine" then
            return "shipicon_miner_ore_xl"
            --return "mej_miner"
        else
            return "shipicon_freighter_xl"
        end
        
    end
    
    return "solid"
end

local shipClassSizes = {
    ship_xl = 5,
    ship_l = 4,
    ship_m = 3,
    ship_s = 2,
    ship_xs = 1
}
local function shipSortFunc(a, b)
    --DebugError("Compare: " .. GetComponentData(a, "name") .. " and " .. GetComponentData(b, "name"))
    local ffiA = ConvertIDTo64Bit(a)
    local ffiB = ConvertIDTo64Bit(b)
    local classA = ffi.string(C.GetComponentClass(ffiA))
    local classB = ffi.string(C.GetComponentClass(ffiB))
    
    if classA == classB then
        return ffi.string(C.GetComponentName(ffiA)) < ffi.string(C.GetComponentName(ffiB))
    end
    
    return shipClassSizes[classA] > shipClassSizes[classB]
end

local spaceAndGrey2 = " " .. colorChar .. "Z"
local commandShipPrefix = colorChar .. "Y" .. "> " .. colorChar .. "X"
local function displayShip(setup, ship, isCommandSelection, isPlayer, isEnemy, updateMode, depth)
    local fontSize = Helper.standardFontSize
    local textHeight = Helper.standardTextHeight
    
    depth = depth or 0
    
    --so you can omit them if you like
    if isCommandSelection == nil then
        isCommandSelection = false
    end
    if updateMode == nil then
        updateMode = false
    end
    if isPlayer == nil then
        isPlayer = isCommandSelection or GetComponentData(ship, "isplayerowned")
    end
    if isEnemy == nil then
        isEnemy = GetComponentData(ship, "isenemy")
    end
    
    local textColor
    if GetComponentData(ship, "ismissiontarget") then
        textColor = menu.holomapColor.missionColor
    elseif isPlayer then
        textColor = menu.holomapColor.playerColor
    elseif isEnemy then
        textColor = menu.holomapColor.enemyColor
    else
        textColor = menu.holomapColor.friendColor
    end
    
    --attach a bunch of stuff to the name as needed
    local name = GetComponentData(ship, "name") or menu.text.unknown
    
    --a yellow something for things that can receive orders
    if isPlayer and getHighestCommander(ship) == ship then
        name = commandShipPrefix .. name
    end
    
    name = applyTargetArrows(setup, ship, name)
    
    --pseudo-tree output with prefix
    if depth > 0 then
        name = string.rep("     ", depth) .. name
    end
    
    local commandString = IsInfoUnlockedForPlayer(ship, "operator_commands") and getCommandString(GetComponentData(ship, "pilot")) or "???"
    
    local childSpaceType = "zone"
    if menu.currentSpaceType == "galaxy" then
        childSpaceType = "cluster"
    elseif menu.currentSpaceType == "cluster" then
        childSpaceType = "sector"
    end
    local subordinates = GetSubordinates(ship)
    
    --different filtering needed here than shouldDisplayShip
    for i = #subordinates, 1, -1 do
        if IsComponentClass(subordinates[i], "ship_xs") or C.GetContextByClass(ConvertIDTo64Bit(subordinates[i]), childSpaceType, false) ~= C.GetContextByClass(ConvertIDTo64Bit(ship), childSpaceType, false) then
            table.remove(subordinates, i)
        end
    end
    local extended = #subordinates ~= 0 and menu.isExtended(ship)
    
    local iconName = getIconName(ship)
    
    --cell for button to extend subordinates (or if command selection, just the number)
    local extendButtonCell
    local hasExtendButton = false
    
    if isCommandSelection then
        extendButtonCell = Helper.createFontString(tostring(#subordinates), false, "center", 255, 255, 255, 100, nil, fontSize, nil, nil, nil, textHeight)
    elseif #subordinates ~= 0 then
        local text = tostring(#subordinates)
        if extended then
            text = "-"..text.."-"
        end
        extendButtonCell = Helper.createButton(Helper.createButtonText(text, "center", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), nil, false, true, 0, 0, 0, Helper.standardTextHeight)
        hasExtendButton = true
    else
        extendButtonCell = ""
    end
    
    --TEMP -- TESTING CHECKBOX STUFF
    --[[
    if isPlayer and not isCommandSelection and getHighestCommander(ship) == ship then
        extendButtonCell = Helper.createCheckBox(menu.checkedComponents[tostring(ship)] ~= nil, false, textColor, true, nil, nil, Helper.standardTextHeight, nil)
    end
    ]]
    
    local classIcon = Helper.createIcon(iconName, false, textColor.r, textColor.g, textColor.b, 100, 0, 0, textHeight, textHeight)
    
    local textCellString = name .. spaceAndGrey2 .. commandString
    
    local rowData = (not isCommandSelection) and {
        obj = ship,
        extendButton = hasExtendButton,
        checkBox = false
    } or nil
    
    if updateMode then
        Helper.updateCellText(menu.selectTable, menu.commandSelectionRow, 1, tostring(#subordinates), menu.white)
        SetCellContent(menu.selectTable, classIcon, menu.commandSelectionRow, 2)
        Helper.updateCellText(menu.selectTable, menu.commandSelectionRow, 3, textCellString, textColor)
    else
        setup:addRow(true, {
            --expand/collapse subordinates, if available
            extendButtonCell,
            --small icon like in X3 map
            classIcon,
            --name
            Helper.createFontString(textCellString, false, "left", textColor.r, textColor.g, textColor.b, 100, nil, fontSize, nil, nil, nil, textHeight),
        }, rowData, {1, 1, 3})
    end
    
    if not isCommandSelection and IsSameComponent(ship, menu.nextSelection) then
        menu.nextSelectedRow = #setup.rows
    end
    
    --if we are extended, display all our subordinates as well
    if extended and not isCommandSelection then
        if #subordinates > 0 then table.sort(subordinates, shipSortFunc) end
        for k, sub in pairs(subordinates) do
            displayShip(setup, sub, nil, nil, nil, nil, depth+1)
        end
    end
end

local function displayStation(setup, station)
    local fontSize = 10
    local textHeight = 16
    
    local nameUnlocked = IsInfoUnlockedForPlayer(station, "name")
    
    local isPlayer = GetComponentData(station, "isplayerowned")
    
    local textColor
    if not nameUnlocked then
        textColor = menu.grey
    elseif GetComponentData(station, "ismissiontarget") then
        textColor = menu.holomapColor.missionColor
    elseif isPlayer then
        textColor = menu.holomapColor.playerColor
    elseif GetComponentData(station, "isenemy") then
        textColor = menu.holomapColor.enemyColor
    else
        textColor = menu.holomapColor.friendColor
    end
    
    local rowData = {
        obj = station,
        extendButton = false,
        checkBox = false
    }
    
    local numIcons = 0
    local hasTradeAgent = GetComponentData(station, "tradesubscription")
    local warningLevel = isPlayer and Helper.hasObjectWarning(station) or 0
    if hasTradeAgent then
        numIcons = numIcons + 1
    end
    if warningLevel > 0 then
        numIcons = numIcons + 1
    end
    
    local extendButtonCell = ""
    
    local classIcon = Helper.createIcon("mej_station", false, textColor.r, textColor.g, textColor.b, 100, 0, 0, Helper.standardTextHeight, Helper.standardTextHeight)
    
    local name = nameUnlocked and GetComponentData(station, "name") or "???"
    local nameCell = Helper.createFontString(name, false, "left", textColor.r, textColor.g, textColor.b, 100, nil, fontSize, nil, nil, nil, textHeight)
    
    local cellContents = {
        --expand/collapse subordinates, if available
        extendButtonCell,
        --small icon like in X3 map
        classIcon,
        --name
        nameCell
    }
    
    if warningLevel > 0 then
        local warningColor = warningLevel > 1 and menu.red or menu.holomapColor.missionColor
        table.insert(cellContents, Helper.createIcon("workshop_error", false, warningColor.r, warningColor.g, warningColor.b, 100, 0, 0, Helper.standardTextHeight, 24))
    end
    if hasTradeAgent then
        table.insert(cellContents, Helper.createIcon("menu_eye", false, 255, 255, 255, 100, 0, 0, Helper.standardTextHeight, 24))
    end
    
    local colSpans
    if numIcons == 2 then
        colSpans = {1, 1, 1, 1, 1}
    elseif numIcons == 1 then
        colSpans = {1, 1, 2, 1}
    else
        colSpans = {1, 1, 3}
    end
    
    setup:addRow(true, cellContents, rowData, colSpans)
    
    
    if IsSameComponent(station, menu.nextSelection) then
        menu.nextSelectedRow = #setup.rows
    end
end

local prevCommandSelection = 0
local function displayCommandSelection(createMode)
    if menu.commandSelectionRow == 0 and not createMode then
        return
    end
    
    if menu.numChecked > 0 then
        local numXL = 0
        local numL = 0
        local numM = 0
        local numS = 0
        for k, ship in pairs(menu.checkedComponents) do
            if IsComponentClass(ship, "ship_xl") then numXL = numXL + 1 end
            if IsComponentClass(ship, "ship_l") then numL = numL + 1 end
            if IsComponentClass(ship, "ship_m") then numM = numM + 1 end
            if IsComponentClass(ship, "ship_s") then numS = numS + 1 end
        end
        local cell1Content = ""
        local cell2Content = ""
        local cell3Content = (textColor("G").."XL: "..textColor("X")..numXL..", ") .. (textColor("G").."L: "..textColor("X")..numL..", ") .. (textColor("G").."M: "..textColor("X")..numM..", ") .. (textColor("G").."S: "..textColor("X")..numS..", ")
        
        if createMode then
            setup:addSimpleRow({
                cell1Content,
                cell2Content,
                cell3Content
            }, nil, {1, 1, 3})
        else
            Helper.updateCellText(menu.selectTable, menu.commandSelectionRow, 1, cell1Content)
            Helper.updateCellText(menu.selectTable, menu.commandSelectionRow, 2, cell2Content)
            Helper.updateCellText(menu.selectTable, menu.commandSelectionRow, 3, cell3Content)
        end
        
    elseif menu.commandSelection ~= 0 then
        displayShip(nil, menu.commandSelection, true, true, false, not createMode)
        
        if not createMode and not IsSameComponent(prevCommandSelection, menu.commandSelection) then
            local orderObj = menu.getOrderObject(true)
            for k, order in ipairs(menu.gridOrders) do
                if order.row ~= nil and order.col ~= nil then
                    menu.refreshOrderButton(order, orderObj)
                end
            end
        end
    else
        if createMode then
            setup:addSimpleRow({
                Helper.createFontString("", false, "center", 255, 255, 255, 100, nil, fontSize, nil, nil, nil, textHeight),
                "",
                menu.text.selectionNone
            }, nil, {1, 1, 3})
        else
            Helper.updateCellText(menu.selectTable, menu.commandSelectionRow, 1, "")
            Helper.updateCellText(menu.selectTable, menu.commandSelectionRow, 2, "")
            Helper.updateCellText(menu.selectTable, menu.commandSelectionRow, 3, menu.text.selectionNone, menu.white)
        end
    end
    
    prevCommandSelection = menu.commandSelection
end

--check the current selection and target, set either one to null if it points to a nonoperational component
function menu.enforceSelections(noCommandUpdate)
    local commandUpdateNeeded = false
    
    if menu.currentSelection ~= 0 and not IsComponentOperational(menu.currentSelection) then
        menu.currentSelection = 0
        menu.setStatusMessage("Selection lost")
    end
    if menu.nextSelection ~= 0 and not IsComponentOperational(menu.nextSelection) then
        menu.nextSelection = 0
    end
    
    if menu.commandSelection ~= 0 and not IsComponentOperational(menu.commandSelection) then
        menu.commandSelection = 0
        commandUpdateNeeded = true
    end
    if menu.commandTargetType == "object" and menu.commandTarget ~= 0 and not IsComponentOperational(menu.commandTarget) then
        menu.commandTarget = 0
        menu.commandTargetType = "none"
    end
    
    for k, ship in pairs(menu.checkedComponents) do
        if not IsComponentOperational(ship) then
            menu.checkedComponents[k] = nil
            menu.numChecked = menu.numChecked - 1
            commandUpdateNeeded = true
        end
    end
    
    if commandUpdateNeeded and not noCommandUpdate then
        displayCommandSelection()
    end
end

function menu.extendObjectButton(ship)
    if menu.isExtended(ship) then
        menu.collapse(ship)
    else
        menu.extend(ship)
    end
    menu.nextSelection = ship
    if not menu.displayMenuRunning then
        menu.displayMenuReason = "extend object button"
        menu.displayMenu()
    end
end

function menu.canViewDetails(obj)
    return (IsComponentClass(obj, "ship") or IsComponentClass(obj, "station")) and IsInfoUnlockedForPlayer(obj, "name") and (CanViewLiveData(obj) or GetComponentData(obj, "tradesubscription"))
end

function menu.createButton1()
    return Helper.createButton(Helper.createButtonText(menu.text.back, "center", Helper.standardFont, 9, 255, 255, 255, 100), nil, false, true, 0, 0, menu.buttonTableButtonWidth, 23, nil, Helper.createButtonHotkey("INPUT_STATE_DETAILMONITOR_B", true))
end
function menu.createButton2()
    return Helper.createButton(Helper.createButtonText(menu.text.zoomOut, "center", Helper.standardFont, 9, 255, 255, 255, 100), nil, false, menu.currentSpaceType ~= "galaxy", 0, 0, menu.buttonTableButtonWidth, 23, nil, Helper.createButtonHotkey("INPUT_STATE_DETAILMONITOR_BACK", true))
end
function menu.createButton3()
    local text
    local enabled
    
    if menu.currentSelection == 0 then
        text = menu.text.comm
        enabled = false
    
    elseif IsComponentClass(menu.currentSelection, "zone") then
        if IsSameComponent(menu.currentSelection, GetActiveGuidanceMissionComponent()) then
            text = menu.text.abortCourse
            enabled = true
        else
            text = menu.text.plotCourse
            enabled = not IsSameComponent(GetContextByClass(GetPlayerPrimaryShipID(), "zone"), menu.currentSelection)
        end
    
    elseif IsComponentClass(menu.currentSelection, "container") then
        text = menu.text.comm
        enabled = not IsSameComponent(menu.currentSelection, GetPlayerPrimaryShipID())
    
    else
        text = menu.text.comm
        enabled = false
    end
    
    return Helper.createButton(Helper.createButtonText(text, "center", Helper.standardFont, 9, 255, 255, 255, 100), nil, false, enabled, 0, 0, menu.buttonTableButtonWidth, 23, nil, Helper.createButtonHotkey("INPUT_STATE_DETAILMONITOR_Y", true))
end
function menu.createButton4()
    local enabled
    local text
    
    if menu.currentSelection == 0 then
        text = "--"
        enabled = false
    else
        if IsComponentClass(menu.currentSelection, "space") then
            text = menu.text.zoomIn
            enabled = true
        else
            text = menu.text.details
            enabled = menu.canViewDetails(menu.currentSelection)
        end
    end
    return Helper.createButton(Helper.createButtonText(text, "center", Helper.standardFont, 9, 255, 255, 255, 100), nil, false, enabled, 0, 0, menu.buttonTableButtonWidth, 23, nil, Helper.createButtonHotkey("INPUT_STATE_DETAILMONITOR_X", true))
end

function menu.button1Clicked()
    menu.onCloseElement("back")
end
function menu.button2Clicked()
    menu.tryZoomOut()
end
function menu.button3Clicked()
    menu.enforceSelections(true)
    if menu.currentSelection == 0 then return end
    
    if IsComponentClass(menu.currentSelection, "zone") then
        if IsSameComponent(menu.currentSelection, GetActiveGuidanceMissionComponent()) then
            Helper.closeMenuForSection(menu, false, "gMainNav_abort_plotcourse")
            menu.cleanup()
        else
            Helper.closeMenuForSection(menu, false, "gMainNav_plotcourse", {menu.currentSelection, false})
            menu.cleanup()
        end
    elseif IsComponentClass(menu.currentSelection, "container") and not IsSameComponent(menu.currentSelection, GetPlayerPrimaryShipID()) then
        menu.tryComm(menu.currentSelection)
    end
end
function menu.button4Clicked()
    menu.enforceSelections(true)
    if menu.currentSelection == 0 then return end
    
    if IsComponentClass(menu.currentSelection, "space") then
        menu.tryZoomIn()
    elseif menu.canViewDetails(menu.currentSelection) then
        menu.objectDetails()
    end
end

function menu.objectDetails()
    Helper.closeMenuForSubSection(menu, false, "gMain_object_closeup", {0, 0, ConvertStringTo64Bit(tostring(menu.currentSelection))})
    menu.cleanup()
end

function menu.updateButtonsRow()
    Helper.removeButtonScripts(menu, menu.buttonTable, 2, 2)
    Helper.removeButtonScripts(menu, menu.buttonTable, 2, 4)
    Helper.removeButtonScripts(menu, menu.buttonTable, 2, 6)
    Helper.removeButtonScripts(menu, menu.buttonTable, 2, 8)
    
    SetCellContent(menu.buttonTable, menu.createButton1(), 2, 2)
    SetCellContent(menu.buttonTable, menu.createButton2(), 2, 4)
    SetCellContent(menu.buttonTable, menu.createButton3(), 2, 6)
    SetCellContent(menu.buttonTable, menu.createButton4(), 2, 8)
    
    Helper.setButtonScript(menu, nil, menu.buttonTable, 2, 2, menu.button1Clicked)
    Helper.setButtonScript(menu, nil, menu.buttonTable, 2, 4, menu.button2Clicked)
    Helper.setButtonScript(menu, nil, menu.buttonTable, 2, 6, menu.button3Clicked)
    Helper.setButtonScript(menu, nil, menu.buttonTable, 2, 8, menu.button4Clicked)
end

function menu.tryComm(component)
    if not GetComponentData(component, "caninitiatecomm") then return end
    local entities = Helper.getSuitableControlEntities(component, true)
    if #entities == 1 then
        Helper.closeMenuForSubConversation(menu, false, "default", entities[1], component, (not Helper.useFullscreenDetailmonitor()) and "facecopilot" or nil)
    else
        Helper.closeMenuForSubSection(menu, false, "gMain_propertyResult", component)
    end
    menu.cleanup()
end

function menu.setupCommandGrid(setup)
    local orderObj = menu.getOrderObject(true)
    
    --just in case...
    for k, order in ipairs(menu.gridOrders) do
        order.row = nil
        order.col = nil
    end
    
    --find "about" the weight of each button
    local numCommandButtonCols = 3
    local numCommandButtonRows = 10
    local commandButtonColWidths = {}
    local totalCommandButtonWidth = Helper.standardSizeX - menu.renderTargetWidth - (8 * (numCommandButtonCols+1))
    local commandButtonWidth = totalCommandButtonWidth / numCommandButtonCols
    for i = 1, numCommandButtonCols do
        table.insert(commandButtonColWidths, commandButtonWidth)
    end
    
    local thisRow = {}
    for k, order in ipairs(menu.gridOrders) do
        --make the new button
        local button = menu.getOrderButton(order, orderObj)
        
        table.insert(thisRow, button)
        order.row = #setup.rows + 1
        order.col = #thisRow
        
        if #thisRow >= numCommandButtonCols then
            setup:addSimpleRow(thisRow)
            thisRow = {}
            if #setup.rows >= numCommandButtonRows then
                break
            end
        end
    end
    
    --if all the orders are there but thisRow isn't empty, pad it and slap it in there
    if #thisRow ~= 0 then
        while #thisRow < numCommandButtonCols do
            table.insert(thisRow, "")
        end
        setup:addSimpleRow(thisRow)
        thisRow = {}
    end
    
    return commandButtonColWidths
end

function menu.getOrderButton(order, orderObj)
    local enabled = orderObj.subject ~= 0 and order.buttonFilter(orderObj)
    local color
    local text = order.buttonText
    if menu.activeGridOrder == order then
        color = menu.holomapColor.missionColor
        text = "> " .. text .. " <"
    else
        color = menu.white
    end
    return Helper.createButton(Helper.createButtonText(text, "center", Helper.standardFont, 9, color.r, color.g, color.b, 100), nil, false, enabled, 0, 0, commandButtonWidth, 23)
end
    

function menu.setCommandGridScripts()
    for k, order in ipairs(menu.gridOrders) do
        if order.row ~= nil and order.col ~= nil then
            Helper.setButtonScript(menu, nil, menu.commandGridTable, order.row, order.col, order.buttonScript)
        end
    end
end

function menu.displayMenu(firstTime)
    menu.displayMenuRunning = true
    
    local gridTopRow = -1
    
    --remove old data
    if not firstTime then
        Helper.removeAllKeyBindings(menu)
        Helper.removeAllButtonScripts(menu)
        Helper.currentTableRow = {}
        Helper.currentTableRowData = nil
        menu.rowDataMap = {}
        
        gridTopRow = GetTopRow(menu.commandGridTable)
    end
    
    Helper.setKeyBinding(menu, menu.onHotkey)
    
    local fixedRows = 0
    
    --make sure they're is still valid
    menu.enforceSelections(true)
    
    --selected object might not have a row because its commanders aren't extended
    if menu.nextSelection ~= 0 and C.IsShip(ConvertIDTo64Bit(menu.nextSelection)) and GetCommander(menu.nextSelection) then
        for k, com in pairs(GetAllCommanders(menu.nextSelection)) do
            menu.extend(com)
        end
    end
    
    --create render target
    --=========================================
    local renderTargetDesc = Helper.createRenderTarget(menu.renderTargetWidth, menu.renderTargetHeight, 0, 0)
    
    --create table for selectable ships
    --=========================================
    local setup = Helper.createTableSetup(menu)
    
    local topSelectRow = nil
    if not firstTime then
        topSelectRow = GetTopRow(menu.selectTable)
    end
    
    local selectColumnWidths = {menu.extendButtonWidth, Helper.standardTextHeight, 0, 24, 24}
    local selectNumColumns = #selectColumnWidths
    
    menu.nextSelectedRow = 0
    --if it's still available, it'll be set by a row change event
    menu.currentSelection = 0
    local spaceType
    local spaceName
    local headerText
    
    if menu.currentSpaceType == "zone" then
        spaceType = ReadText(20001, 301)
    elseif menu.currentSpaceType == "sector" then
        spaceType = ReadText(20001, 201)
    elseif menu.currentSpaceType == "cluster" then
        spaceType = ReadText(20001, 101)
    elseif menu.currentSpaceType == "galaxy" then
        spaceType = ReadText(20001, 901)
    end
    
    if menu.currentSpaceType == "galaxy" then
        headerText = spaceType
    else
        headerText = spaceType .. ": " .. ffi.string(C.GetComponentName(menu.currentSpace))
    end
    
    --name of zone/sector/cluster/galaxy
    setup:addHeaderRow({
        Helper.createFontString(headerText, false, "left", 255, 255, 255, 100, Helper.headerRow1Font, Helper.headerRow1FontSize, false, Helper.headerRow1Offsetx, Helper.headerRow1Offsety, Helper.headerRow1Height, Helper.headerRow1Width),
    }, nil, {selectNumColumns})
    
    --selected ship or none
    if menu.commandSelection ~= 0 then
        displayShip(setup, menu.commandSelection, true, true, false)
    else
        setup:addSimpleRow({
            Helper.createFontString("", false, "center", 255, 255, 255, 100, nil, fontSize, nil, nil, nil, textHeight),
            "",
            "-- None --"
        }, nil, {1, 1, 3})
    end
    menu.commandSelectionRow = #setup.rows
    
    --separator
    setup:addHeaderRow({Helper.createFontString("", nil, nil, nil, nil, nil, nil, nil, 6, nil, nil, nil, 6)}, nil, {selectNumColumns})
    
    fixedRows = #setup.rows
    
    if menu.currentSpaceType == "zone" then
        menu.displayZoneList(setup)
    else
        menu.displayChildSpaces(setup)
    end
    
    local selectDesc = setup:createCustomWidthTable(selectColumnWidths, false, false, true, 1, fixedRows, menu.selectTableOffsetX, 0, menu.selectTableHeight, nil, topSelectRow, menu.nextSelectedRow)
    
    --table for ABXY buttons
    --=========================================
    
    setup = Helper.createTableSetup(menu)
    setup:addRow(false, {
        menu.statusMessage,
        Helper.createFontString("", false, "right", 255, 255, 255, 100)
    }, nil, {4,4,1})
    setup:addSimpleRow({ 
        Helper.getEmptyCellDescriptor(),
        menu.createButton1(),
        Helper.getEmptyCellDescriptor(),
        menu.createButton2(),
        Helper.getEmptyCellDescriptor(),
        menu.createButton3(),
        Helper.getEmptyCellDescriptor(),
        menu.createButton4(),
        Helper.getEmptyCellDescriptor()
    }, nil, nil, false, menu.transparent)
    
    local buttonTableDesc = setup:createCustomWidthTable(
    {
        menu.buttonTableSpacerWidth,
        menu.buttonTableButtonWidth,
        menu.buttonTableSpacerWidth,
        menu.buttonTableButtonWidth,
        menu.buttonTableSpacerWidth,
        menu.buttonTableButtonWidth,
        menu.buttonTableSpacerWidth,
        menu.buttonTableButtonWidth,
        menu.buttonTableSpacerWidth
    }, false, false, false, 2, 2, 0, Helper.standardSizeY-50, 0, false)
    
    --command button table
    --=========================================
    
    setup = Helper.createTableSetup(menu)
    commandButtonColWidths = menu.setupCommandGrid(setup)
    
    local gridDesc = setup:createCustomWidthTable(commandButtonColWidths, false, false, false, 3, 0, menu.selectTableOffsetX + 5, menu.commandTableOffsetY, Helper.standardSizeY - menu.commandTableOffsetY, nil, gridTopRow ~= -1 and gridTopRow or nil)
    
    --create and display the table view
    --=========================================
    menu.selectTable, menu.buttonTable, menu.commandGridTable, menu.renderTarget = Helper.displayThreeTableRenderTargetView(menu, selectDesc, buttonTableDesc, gridDesc, renderTargetDesc)
    
    for i = fixedRows + 1, GetTableNumRows(menu.selectTable) do
        local data = menu.rowDataMap[i]
        if data ~= nil then
            if IsComponentClass(data.obj, "space") then
                Helper.setButtonScript(menu, nil, menu.selectTable, i, 1, function() menu.tryZoomIn(data.obj) end)
            else
                if data.checkBox then
                    Helper.setCheckBoxScript(menu, nil, menu.selectTable, i, 1, function() menu.checkBoxSwitched(data.obj, i) end)
                elseif data.extendButton then
                    Helper.setButtonScript(menu, nil, menu.selectTable, i, 1, function() menu.extendObjectButton(data.obj) end)
                end
            end
        end
    end
    
    --apply ABXY button scripts
    Helper.setButtonScript(menu, nil, menu.buttonTable, 2, 2, menu.button1Clicked)
    Helper.setButtonScript(menu, nil, menu.buttonTable, 2, 4, menu.button2Clicked)
    Helper.setButtonScript(menu, nil, menu.buttonTable, 2, 6, menu.button3Clicked)
    Helper.setButtonScript(menu, nil, menu.buttonTable, 2, 8, menu.button4Clicked)
    
    menu.setCommandGridScripts()
    
    Helper.releaseDescriptors()
    
    menu.displayMenuRunning = false
end

function menu.checkBoxSwitched(component, row)
    if menu.checkedComponents[tostring(component)] ~= nil then
        menu.checkedComponents[tostring(component)] = nil
        menu.numChecked = menu.numChecked - 1
    else
        menu.checkedComponents[tostring(component)] = component
        menu.numChecked = menu.numChecked + 1
    end
    menu.setStatusMessage("Components checked: " .. menu.numChecked)
end

local function displayGate(setup, gate)
    local name, destination = GetComponentData(gate, "name", "destination")
    local destinationText
    
    local textColor
    if GetComponentData(gate, "ismissiontarget") then
        textColor = menu.holomapColor.missionColor
    else
        textColor = menu.white
    end
   
    if destination then
        destinationText = GetComponentData(GetContextByClass(destination, "cluster"), "name")
    else
        destinationText = menu.text.unknownSystem
    end
    
    name = name .. ": " .. destinationText
    
    name = applyTargetArrows(setup, gate, name)
    
    local rowData = {
        obj = gate,
        extendButton = false,
        checkBox = false
    } or nil
    
    setup:addRow(true, {
        "",
        Helper.createIcon("mej_jumpgate", false, textColor.r, textColor.g, textColor.b, 100, 0, 0, Helper.standardTextHeight, Helper.standardTextHeight),
        Helper.createFontString(name, false, "left", textColor.r, textColor.g, textColor.b, 100, nil, Helper.standardFontSize, nil, nil, nil, Helper.standardTextHeight),
    }, rowData, {1, 1, 3})
    
    if IsSameComponent(gate, menu.nextSelection) then
        menu.nextSelectedRow = #setup.rows
    end
end

function menu.displayZoneList(setup)
    local luaSpace = ConvertStringTo64Bit(tostring(menu.currentSpace))
    
    local separatorNeeded = false
    
    local yields = GetZoneYield(luaSpace)
    for k, yield in ipairs(yields) do
        local yieldText = yield.name .. ": " .. ConvertIntegerString(yield.amount, true, 3, true) .. " / " .. ConvertIntegerString(yield.max, true, 3, true)
        setup:addRow(false, {yieldText}, nil, {5})
        separatorNeeded = true
    end
    
    local allStations = GetContainedStations(luaSpace, true)
    for k, station in ipairs(allStations) do
        displayStation(setup, station)
        separatorNeeded = true
    end
    
    local allGates = GetGates(luaSpace, true)
    for k, gate in ipairs(allGates) do
        displayGate(setup, gate)
        separatorNeeded = true
    end
    
    if separatorNeeded then
        setup:addHeaderRow({Helper.createFontString("", nil, nil, nil, nil, nil, nil, nil, 6, nil, nil, nil, 6)}, nil, {5})
    end
    
    local allShips = GetContainedShips(luaSpace, true)
    local playerShips = {}
    local enemyShips = {}
    local neutralShips = {}
    for k, ship in ipairs(allShips) do
        if shouldDisplayShip(ship, "zone") then
            if GetComponentData(ship, "isplayerowned") then
                table.insert(playerShips, ship)
            elseif GetComponentData(ship, "isenemy") then
                table.insert(enemyShips, ship)
            else
                table.insert(neutralShips, ship)
            end
        end
    end
    
    table.sort(playerShips, shipSortFunc)
    table.sort(enemyShips, shipSortFunc)
    table.sort(neutralShips, shipSortFunc)
    
    for k, ship in ipairs(playerShips) do
        displayShip(setup, ship, false, true, false)
    end
    for k, ship in ipairs(enemyShips) do
        displayShip(setup, ship, false, false, true)
    end
    for k, ship in ipairs(neutralShips) do
        displayShip(setup, ship, false, false, false)
    end
end

function menu.displayChildSpaces(setup)
    --determine list of spaces and icon
    local spaces
    local childSpaceType
    local shortNameHere
    local luaCurSpace = ConvertStringTo64Bit(tostring(menu.currentSpace))
    if menu.currentSpaceType == "galaxy" then
        spaces = GetClusters(true)
        spaceIcon = "menu_cluster"
        childSpaceType = "cluster"
        shortNameHere = ""
    elseif menu.currentSpaceType == "cluster" then
        spaces = GetSectors(luaCurSpace)
        spaceIcon = "menu_sector"
        childSpaceType = "sector"
        shortNameHere = GetComponentData(luaCurSpace, "mapshortname") .. "."
    elseif menu.currentSpaceType == "sector" then
        spaces = GetZones(luaCurSpace)
        spaceIcon = "menu_zone"
        childSpaceType = "zone"
        shortNameHere = GetComponentData(GetContextByClass(luaCurSpace, "cluster"), "mapshortname") .. "." .. GetComponentData(luaCurSpace, "mapshortname") .. "."
    else
        return
    end
    
    for k, space in ipairs(spaces) do
        local rowData = {
            obj = space,
            extendButton = true
        }
        
        local name = GetComponentData(space, "name")
        name = shortNameHere .. GetComponentData(space, "mapshortname") .. ": " .. name
        
        local nameColor = menu.white
        local playerShipsHere = GetContainedShipsByOwner("player", space)
        filterByDisplayable(playerShipsHere, childSpaceType)
        local playerStationsHere = GetContainedStationsByOwner("player", space)
        
        if GetComponentData(space, "ismissiontarget") then
            nameColor = menu.holomapColor.missionColor
        elseif #playerShipsHere > 0 or #playerStationsHere > 0 then
            nameColor = menu.holomapColor.playerColor
        end
        
        local selectZoneButton = Helper.createButton(nil, Helper.createButtonIcon(spaceIcon, nil, 255,255,255,100), false, true, 0, 0, menu.extendButtonWidth, menu.extendButtonWidth)
        
        local textCell
        local infoText = ""
        if (menu.currentSpaceType == "cluster" or menu.currentSpaceType == "sector") and HasShipyard(space) then
            infoText = infoText .. " [" .. ReadText(1001, 92) .. "]"
        end
        if menu.currentSpaceType == "sector" then
        
            --zones get a jumpbeacon tag if they have one, also a list of yields underneath if they have any
            
            if GetComponentData(space, "hasjumpbeacon") then
                infoText = infoText .. " [" .. ReadText(20109, 2101) .. "]"
            end
            
            local yields = GetZoneYield(space)
            if #yields > 0 then
                infoText = infoText .. "\n"
                for i, yield in ipairs(yields) do
                    if i > 1 then
                        infoText = infoText .. ", "
                    end
                    infoText = infoText .. GetWareData(yield.ware, "shortname")
                end
            end
        end
        if string.len(infoText) > 0 then
            textCell = name .. spaceAndGrey2 .. infoText
        else
            textCell = name
        end
        
        setup:addRow(true, {
            --button to go into zone
            selectZoneButton,
            --name and details
            Helper.createFontString(textCell, false, "left", nameColor.r, nameColor.g, nameColor.b, nameColor.a, nil, 9, true, nil, nil, menu.extendButtonWidth),
        }, rowData, {1,4})
        
        if IsSameComponent(space, menu.nextSelection) then
            menu.nextSelectedRow = #setup.rows
        end
        
        if menu.currentSpaceType == "sector" then
            for k, station in ipairs(playerStationsHere) do
                displayStation(setup, station)
            end
            if #playerShipsHere > 0 then table.sort(playerShipsHere, shipSortFunc) end
            for k, ship in ipairs(playerShipsHere) do
                displayShip(setup, ship, false, true, false)
            end
        end
    end
end

function menu.componentSelected(rowdata, highlight)
    if not rowdata then
        return
    end
    
    local component = rowdata.obj
    
    menu.currentSelection = component
    Helper.updateCellText(menu.buttonTable, 1, 5, getComponentInfo(menu.currentSelection))
    menu.updateButtonsRow()
    
    
    if component ~= 0 and C.IsShip(ConvertIDTo64Bit(component)) and GetComponentData(component, "isplayerowned") then
        --don't change the command selection if it's a ship who can't receive orders
        local newSelection = getHighestCommander(component)
        menu.commandSelection = newSelection or menu.commandSelection
        displayCommandSelection()
    end
    
    --ships and stuff really mustn't be highlighted when the holomap isn't in zone mode, it clearly wasn't made for it and looks very screwy, so we prevent it
    if menu.holomap ~= 0 and menu.currentSelection ~= 0 and highlight then
        if (menu.currentSpaceType ~= "zone" and not IsComponentClass(menu.currentSelection, "space")) then
            --C.ClearHighlightMapComponent(menu.holomap)
            C.SetHighlightMapComponent(menu.holomap, ConvertIDTo64Bit(GetContextByClass(component, "zone")), false)
        else
            C.SetHighlightMapComponent(menu.holomap, ConvertIDTo64Bit(component), false)
        end
    end
end

function menu.onRowChangedSound()
    if menu.ignoreSelectRowChange == 0 then
        PlaySound("ui_table_row_change")
    end
end
function menu.onRowChanged(row, rowdata, whichTable)
    if whichTable == menu.selectTable then
        menu.componentSelected(rowdata and rowdata or nil, true)
    end
end

function menu.softTarget(obj)
    ffiObj = ConvertIDTo64Bit(obj)
    
    --[[
    if not C.IsShip(ffiObj) then
        return
    end
    ]]
    if IsComponentClass(GetPlayerRoom(), "dockingbay") then
        return
    end
    if IsComponentClass(obj, "jumpbeacon") then
        return
    end
    if IsSameComponent(obj, GetPlayerPrimaryShipID()) then
        return
    end
    
    if C.SetSofttarget(ffiObj) then
        menu.nextSelection = obj
        if not menu.displayMenuRunning then
            menu.displayMenuReason = "new soft target"
            menu.displayMenu()
        end
    end
end

menu.updateInterval = 0.5
function menu.onUpdate()
    menu.enforceSelections(true)
    
    --on first update call, set up the holomap
    if menu.activateMap then
        menu.activateMap = false
        
        local renderX0, renderX1, renderY0, renderY1 = Helper.getRelativeRenderTargetSize(menu.renderTarget)
        local rendertargetTexture = GetRenderTargetTexture(menu.renderTarget)
        
        if rendertargetTexture then
            menu.holomap = C.AddHoloMap(rendertargetTexture, renderX0, renderX1, renderY0, renderY1)
            
            if menu.holomap ~= 0 then
                C.ShowUniverseMap(menu.holomap, menu.currentSpace, true, 0)
                if menu.currentSelection ~= 0 then
                    C.SetHighlightMapComponent(menu.holomap, ConvertIDTo64Bit(menu.currentSelection), true)
                end
            end
        end
    end
    
    if menu.nextUpdateQuickly then
        menu.nextUpdateQuickly = false
        menu.updateHolomap(true)
    else
        displayCommandSelection()
        Helper.updateCellText(menu.buttonTable, 1, 5, getComponentInfo(menu.currentSelection))
    end
end

menu.holomapUpdateInterval = 3
function menu.updateHolomap(force)
    local curTime = GetCurRealTime()
    
    if curTime > menu.lastHolomapUpdate + menu.holomapUpdateInterval then
        menu.lastHolomapUpdate = curTime
        
        menu.nextSelection = menu.currentSelection
        
        if not menu.displayMenuRunning then
            menu.displayMenuReason = "holo map update"
            menu.displayMenu()
        end
    end
end

function menu.onRenderTargetMouseDown()
    menu.timeLastMouseDown = GetCurRealTime()
    C.StartPanMap(menu.holomap)
end

function menu.onRenderTargetMouseUp()
    C.StopPanMap(menu.holomap)
    if GetCurRealTime() < menu.timeLastMouseDown + 0.2 then
        menu.mapClicked("left")
    end
end

function menu.onRenderTargetRightMouseDown()
    menu.timeLastRightMouseDown = GetCurRealTime()
    C.StartRotateMap(menu.holomap)
end


function menu.onRenderTargetRightMouseUp()
    C.StopRotateMap(menu.holomap)
    if GetCurRealTime() < menu.timeLastRightMouseDown + 0.2 then
        menu.mapClicked("right")
    end
end

function menu.onRenderTargetScrollDown()
    C.ZoomMap(menu.holomap, 1)
end

function menu.onRenderTargetScrollUp()
    C.ZoomMap(menu.holomap, -1)
end

function menu.onSelectElement(tab)
    local rowData = menu.rowDataMap[Helper.currentTableRow[menu.selectTable]]
    if rowData ~= nil then
        menu.onItemDoubleClick(rowData.obj)
    end
end

function menu.onRenderTargetDoubleClick()
    local ffiPicked = C.GetPickedMapComponent(menu.holomap)
    local luaPicked = ConvertStringTo64Bit(tostring(ffiPicked))
    
    if ffiPicked ~= 0 then
        menu.onItemDoubleClick(luaPicked)
    end
end

--for when something is double clicked by either table or map
function menu.onItemDoubleClick(component)
    if menu.currentSpaceType == "zone" then
        menu.softTarget(component)
    elseif menu.currentSpaceType == "sector" or menu.currentSpaceType == "cluster" or menu.currentSpaceType == "galaxy" then
        menu.tryZoomIn(component)
    end
end

local function getApplicableOrders(orderInfo)
    local result = {}
    for k, order in pairs(menu.issuableOrders) do
        if order.filter(orderInfo) then
            table.insert(result, order)
        end
    end
    return result
end

function menu.mapClicked(button)
    if button == "left" then
    
        --left click: try to select an object or space
        local ffiPicked = C.GetPickedMapComponent(menu.holomap)
        local luaPicked = ConvertStringTo64Bit(tostring(ffiPicked))
        
        -- if ffiPicked ~= 0 and C.IsComponentOperational(ffiPicked) and not IsComponentClass(luaPicked, "ship_xs") and not IsComponentClass(luaPicked, "station") then
        if ffiPicked ~= 0 and C.IsComponentOperational(ffiPicked) and not IsComponentClass(luaPicked, "ship_xs") then
            menu.nextSelection = luaPicked
            if not menu.displayMenuRunning then
                menu.displayDueToTarget = true
                menu.displayMenuReason = "left click on map"
                menu.displayMenu()
            end
        end
    
    elseif menu.commandSelection ~= 0 then
        --right click: try to select command target and issue order
        local ffiPicked = C.GetPickedMapComponent(menu.holomap)
        local luaPicked = ConvertStringTo64Bit(tostring(ffiPicked))
        
        if ffiPicked == 0 or IsComponentClass(luaPicked, "station") then
            --target a point in space
            local clickOffset = ffi.new("UIPosRot")
            local offsetValid = C.GetMapPositionOnEcliptic(menu.holomap, clickOffset, true)
            if offsetValid then
                menu.commandTarget = clickOffset
                menu.commandTargetType = "position"
            end
        else
            --target an object
            if C.IsComponentOperational(ffiPicked) then
                menu.commandTarget = luaPicked
                menu.commandTargetType = "object"
            end
        end
        
        --make sure nothing got blown up since we last looked
        menu.enforceSelections()
        --if we have a subject and target, try to issue order
        if menu.commandSelection ~= 0 then
            local orderInfo = menu.getOrderObject()
            
            if menu.activeGridOrder ~= nil then
                if menu.activeGridOrder.filter(orderInfo) then
                    PlaySound(menu.commandAcceptSound)
                    --menu.setStatusMessage(GetComponentData(menu.commandSelection, "name") .. textColor("X") .. " will " .. menu.activeGridOrder.buttonText)
                    menu.setStatusMessage(GetComponentData(menu.commandSelection, "name") .. textColor("X") .. " -> " .. menu.activeGridOrder.buttonText .. " " .. menu.text.commandAccepted)
                    menu.activeGridOrder.issue(orderInfo)
                else
                    PlaySound(menu.commandRejectSound)
                    menu.setStatusMessage(menu.text.commandRejected)
                end
                menu.setActiveGridOrder(nil)
            else
                local applicable = getApplicableOrders(orderInfo)
                if #applicable == 1 then
                    PlaySound(menu.commandAcceptSound)
                    
                    --menu.setStatusMessage(GetComponentData(menu.commandSelection, "name") .. textColor("X") .. " will " .. applicable[1].name)
                    menu.setStatusMessage(GetComponentData(menu.commandSelection, "name") .. textColor("X") .. " -> " .. applicable[1].name .. " " .. menu.text.commandAccepted)
                    
                    if menu.numChecked == 0 then
                        applicable[1].issue(orderInfo)
                    else
                        for k, ship in pairs(menu.checkedComponents) do
                            orderInfo.subject = ship
                            applicable[1].issue(orderInfo)
                        end
                    end
                else
                    PlaySound(menu.commandRejectSound)
                    menu.setStatusMessage(menu.text.commandRejected)
                end
            end
        end
    end
end

function menu.tryZoomOut()
    local success = false
    
    local prevSpace = menu.currentSpace
    
    if menu.currentSpaceType == "cluster" then
        menu.currentSpaceType = "galaxy"
        menu.currentSpace = C.GetContextByClass(menu.currentSpace, "galaxy", true)
        success = true
        
    elseif menu.currentSpaceType == "sector" then
        menu.currentSpaceType = "cluster"
        menu.currentSpace = C.GetContextByClass(menu.currentSpace, "cluster", true)
        success = true
        
    elseif menu.currentSpaceType == "zone" then
        menu.currentSpaceType = "sector"
        menu.currentSpace = C.GetContextByClass(menu.currentSpace, "sector", true)
        success = true
        
    end
    
    if success then
        menu.nextSelection = ConvertStringToLuaID(tostring(prevSpace))
        --DebugError("Zooming out: next selection is " .. tostring(menu.nextSelection))
        
        menu.displayMenuReason = "zoom out"
        menu.displayMenu(false)
        
        if menu.holomap ~= 0 then
            C.ClearHighlightMapComponent(menu.holomap)
            C.ShowUniverseMap(menu.holomap, menu.currentSpace, true, true)
        end
    end
end

--component argument is optional
function menu.tryZoomIn(component)
    if menu.currentSpaceType == "zone" then
        return
    end
    --if no component specified, see if the select table has something valid selected
    if component == nil then
        rowData = menu.rowDataMap[Helper.currentTableRow[menu.selectTable]]
        if rowData ~= nil then
            component = rowData.obj
        end
    end
    if component == nil or component == 0 or not IsComponentClass(component, "space") then
        return
    end
    
    local success = false
    
    if menu.currentSpaceType == "galaxy" then
        menu.currentSpaceType = "cluster"
        menu.currentSpace = ConvertIDTo64Bit(component)
        success = true
    elseif menu.currentSpaceType == "cluster" then
        menu.currentSpaceType = "sector"
        menu.currentSpace = ConvertIDTo64Bit(component)
        success = true
    elseif menu.currentSpaceType == "sector" then
        menu.currentSpaceType = "zone"
        menu.currentSpace = ConvertIDTo64Bit(component)
        success = true
    end
    
    if success then
        menu.displayMenuReason = "zoom in"
        menu.displayMenu(false)
        if menu.holomap ~= 0 then
            C.ClearHighlightMapComponent(menu.holomap)
            C.ShowUniverseMap(menu.holomap, menu.currentSpace, true, true)
        end
    end
end

function menu.onHotkey(action)
    menu.enforceSelections()
    if action == "INPUT_ACTION_ADDON_DETAILMONITOR_C" then
        if menu.currentSelection ~= 0 then
            menu.tryComm(menu.currentSelection)
        end
    end
    if action == "INPUT_ACTION_ADDON_DETAILMONITOR_I" then
        if menu.currentSelection ~= 0 and menu.canViewDetails(menu.currentSelection) then
            menu.objectDetails()
        end
    end
end

--little hack, play the sound in onCloseElement, so it doesn't play when the menu is refreshed
function menu.onCloseElementSound()
end
function menu.onCloseElement(dueToClose)
    PlaySound("ui_menu_close")
    if dueToClose == "close" then
        menu.cleanup()
        Helper.closeMenuAndCancel(menu)
    else
        menu.cleanup()
        Helper.closeMenuAndReturn(menu)
    end
end

function menu.cleanup()
    if menu.holomap ~= 0 then
        C.RemoveHoloMap2()
        menu.holomap = 0
    end
    UnregisterEvent("updateHolomap", menu.updateHolomap)
    
    menu.currentSelection = nil
    menu.commandTarget = nil
    menu.nextSelection = nil
    
    menu.currentSpace = nil
    menu.currentSpaceType = nil
    
    menu.nextUpdateQuickly = nil
    
    Helper.standardFontSize = 14
    Helper.standardTextHeight = 24
    
    menu.shouldBeClosed = true
    
    menu.selectTable = nil
    menu.commandGridTable = nil
    menu.buttonTable = nil
    
    UnregisterAddonBindings("ego_detailmonitor")
end

init()